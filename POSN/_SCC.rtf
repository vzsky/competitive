{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset222 Thonburi;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Strongly connected components\
\
Algorithm \
- Kosaraju\'92s\
- Tarjan\'92s\
\
Kosaraju\'92s Algorithm : \
	\
	
\f1 Graph g;\
	Graph g\'92 = transpose (g)\
	DFS on g and store node sorted by exit time in stack s // avoid repeating node\
	*** Will not work on self implementing stacks ***\
	For every node x in stack s :\
		DFS node x on g\'92\
		For every reachable nodes :\
			nodes is in the same SCC group\
			mark nodes out of stack\
\
Tarjan\'92s Algorithm : \
	\
	Define \
		index : node itself\
		lowlink :	 root of node ( lowest index reachable node )\
				def of inf\
		vertex 	-> inside stack : DFSing\
				-> outside stack : NOT DFSing\
\
	1) DFSing from node u -> node v :\
		v is not visited or backtracting :\
			lowlink[u] = min( lowlink[u], lowlink[v])\
			DFS from node v -> children\
		v is visited :\
			lowlink[u] = min( lowlink[u], index[v])\
			stop DFS\
\
	2) if lowlink == index at some point (during backtracting?)\
		that node is root of scc\
			pop stack until the root of scc is popped\
			those popped nodes are in the same scc\
			\
	}